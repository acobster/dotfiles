## PARTITIONS

### Partitions strategy v2: BTRFS subvolums + LUKS

1. Boot
2. Btrfs+LUKS

See also:

- [Ubuntu 20.04 btrfs-luks + timeshift](https://www.youtube.com/watch?v=yRSElRlp7TQ)
- [Disko Btrfs+LUKS example](https://github.com/nix-community/disko/blob/master/example/luks-btrfs-subvolumes.nix)

Tangentially related videos found while researching:

- [Introduction to LVM](https://www.youtube.com/watch?v=dMHFArkANP8)
- [Encrypting Linux fs with LUKS](https://www.youtube.com/watch?v=woHtfaFDWBU)

### Partitions strategy v1

**This is an old version of the partition strategy, preserved here for historical purposes. The strategy above is simpler and takes better advantage of Btrfs.**

On my main driver I want the following partitions:

1. Boot
    - EFI
    - 200M
2. Swap
    - Linux Swap
    - 2G
    - LUKS-encrypted
3. NixOS
    - EXT4? Btrfs?
    - 100GB+
    - LUKS-encrypted
4. Home
    - Btrfs
    - Remaining HD space
    - LUKS-encrypted

Look into [Disko](https://github.com/nix-community/disko?tab=readme-ov-file) to [provision](https://github.com/nix-community/disko?tab=readme-ov-file#sample-configuration-and-cli-command) this for us

Upon creating the above layout, running `nixos-generate-config` generated a `hardware-configuration.nix` file like this:

```nix
# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, modulesPath, ... }:

{
  imports =
    [ (modulesPath + "/installer/scan/not-detected.nix")
    ];

  boot.initrd.availableKernelModules = [ "xhci_pci" "nvme" "usb_storage" "sd_mod" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ ];
  boot.extraModulePackages = [ ];

  fileSystems."/" =
    { device = "/dev/disk/by-uuid/b0beb6d3-b980-45c7-85fb-67191ff910b8";
      fsType = "btrfs";
    };

  fileSystems."/boot" =
    { device = "/dev/disk/by-uuid/5D57-A897";
      fsType = "vfat";
      options = [ "fmask=0022" "dmask=0022" ];
    };

  fileSystems."/home" =
    { device = "/dev/disk/by-uuid/5e39dd22-a482-4f3f-8453-f1471e333172";
      fsType = "btrfs";
    };

  swapDevices =
    [ { device = "/dev/disk/by-uuid/1314445b-fd04-438a-b7da-ab9c4be1a747"; }
    ];

  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
  networking.useDHCP = lib.mkDefault true;
  # networking.interfaces.enp0s31f6.useDHCP = lib.mkDefault true;
  # networking.interfaces.wlp4s0.useDHCP = lib.mkDefault true;

  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  hardware.cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}
```

## Fun FIFO / Named Pipes hack

The `bin/consume` script in this repo is my favorite Bash script I've ever written.

I originally learned the concept of FIFOs, AKA named pipes, from an episode of Gary Bernhardt's Destroy All Software screencast. In that episode, Gary describes a general Unix test runner that accepts arbitrary commands and prints their output, listening in an infinite loop and running each command as it comes in.

He starts with a humble offering, which you can run directly on the command line:

```
mkfifo test-commands
cat test-commands
```

What the `mkfifo` command does is create a file called `test-commands` of type named pipe, a special Unix file type. The `cat` command will block until it reads something from the pipe.

So when will that happen? When we write to it (from, say, a separate terminal window):

```sh
echo 'hello pipe' > test-commands
```

The `cat` process will now spit out `hello pipe` and exit normally. `echo` implicity writes an EOF to `test-commands`, so `cat` finished reading and terminates like it would on any other file.

This works because `test-commands`, like any ol' Unix pipe, has a "read end" and a "write end". The special thing about names pipes is that they get a concrete filesystem path, just like a normal file. This lets us write to it from anywhere else on the system, like we just did.

https://github.com/acobster/dotfiles/commit/9fdab8961771809bace27ff671dc49df069b6487
https://github.com/acobster/dotfiles/commit/c11edb0d3fd19ae6da8eadf7d0820cdd6a4f1e44

## MISC

- [Horrible screen flickering on Dell XPS](https://www.dell.com/community/en/conversations/linux-general/xps-13-7390-ubuntu-screen-flickering/647f8528f4ccf8a8de410276)
